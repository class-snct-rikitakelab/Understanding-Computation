require "./statement_script.rb"

# スモールステップ意味論は大部分が反復で
# 仮想マシンは繰り返し簡約ステップすることが必要
# それは自身が入力として必要としている情報と同じ種類の出力を生み出すために構成される
# それはそれらをこの繰り返しアプリケーションに適するようにします
# スモールステップのアプローチはプログラム全体を実行することが難しい複雑なものを、
# 説明や分析が簡単なより小さいかけらに切り分けることが利点
# だけど遠回りに感じる
# 全体のプログラム構造がどのように働くか説明する代わりに、
# 私達はただそれがどれほど簡約できるかを少し示します
# なぜ私達は、それの実行の仕方についての完璧なストーリを言うことで、
# もっと直接的に文を説明できないのでしょうか？
# 私達はできます。それがビッグステップ意味論お基礎です。
#
# ビッグステップ意味論の考えはどのように式や文から直接結果を得るかを明示することです
# これは必然的に反復的プロセスよりもむしろ
# 再帰的なプログラムの実行についての考えを含みます
# ビッグステップ意味論は
# 「大きな式を評価するために私達は全ての小さな部分式を評価して、それから
#  それらの結果を最後の答えを得るために合成します」
#
# これはスモールステップのアプローチよりも自然に感じます。
# しかしそれは後述する細かな注意が欠けてます
# 例えばスモールステップ意味論は起こると思われる命令について明言します。
# なぜなら全ての点でそれは次の段階の簡約があるべきだということを確認するが、
# しかしビッグステップ意味論は度々ちょうど実行するための命令を
# 必然的に明示する事無しで実行するための部分コンピュテーションという
# ゆるいスタイルで書かれます
# スモールステップ意味論も私達にコンピュテーションの中間段階を観察する
# 簡単な方法を与えます
# このトレードオフを理解するために一般の言語構成概念を再訪問し。
# どのようにRubyでビッグステップ意味論を実行するか見ましょう
# スモールステップ意味論は状態の経過を追い、簡約を繰り返し実行するため
# Machine classが必要でした。
# しかし私達はここでは必要ありません。なぜならビッグステップのルールは
# 一回の施行で抽象的な構文木を歩くことによってプログラム全体の結果を計算します。
# なので扱うべき状態や繰り返しがありません。
# 私達はただevaluateメソッドを指揮と文のクラスに定義しそれを直接呼び出せばよいです

# 式
# 部分式が既に大きな計算の一部として使われている時、スモールステップ意味論で私達は
# 《1 + 2》のような簡約できる式と《3》のような簡約できない式を
# 簡約ルールが言うとおりに区別する必要がありました。
# しかしビッグステップ意味論ではすべての式は評価できます。
# ただの区別は、自身をすぐに評価できる式を作りたかったならば、
# 計算を実行して異なる式を評価する式もあります。
# ビッグステップ意味論の目標はスモールステップ意味論の振る舞いと同じランタイムを
# 作ることで、それは私達はビッグステップのルールに,
# スモールステップのルールの繰り返しアプリケーションが結局は生じることに同意する
# それそれの種類のプログラム構造を期待してます。
# （これは操作上の意味論が数学的に書かれている時にそれは正式に解決される）
# NumberやBooleanのような値のスモールステップルールは、私達はそれらを全く
# 簡約できないということを言っています。なのでそれらのビッグステップのルールは
# とても簡単です。つまり値はすぐに自身を評価します。

# 

class Number
  def evaluate(environment)
    self
  end
end

class Boolean
  def evaluate(environment)
    self
  end
end

# Variable 式はスモールステップ意味論では値に変わる前に一度簡約されることを許される
# ということでユニークです。なのでそのビッグステップのルールはスモールステップのと
# 同じです。つまりそれは環境内の変数を見てそしてその値を返します。

class Variable
  def evaluate(environment)
    environment[name]
  end
end

# 二項式Add,Multiply,LessThanは少し面白いです。それらはRubyのオペランドに当たる
# 両方の値を合成する前に左右の部分式を再帰的に評価する必要があります

class Add
  def evaluate(environment)
    Number.new(left.evaluate(environment).value + right.evaluate(environment).value)
  end
end

class Multiply
  def evaluate(environment)
    Number.new(left.evaluate(environment).value * right.evaluate(environment).value)
  end
end

class LessThan
  def evaluate(environment)
    Boolean.new(left.evaluate(environment).value < right.evaluate(environment).value)
  end
end

# これらのビッグステップの式の意味論が正しいか調べるため、
# こちらがRubyコンソール上での活動です

Number.new(23).evaluate({})
Variable.new(:x).evaluate({:x Number.new(23) })
LessThan.new(
 Add.new(Variable.new(:x),Number.new(2)),
 Variable.new(:y)
).avaluate({ x: Number.new(2), y: Number.new(5) })

# 文
# 私達が文の振る舞いを明言する時この意味論のスタイルは輝きます
# 式はスモールステップ意味論では他の式に簡約されますが、
# 文は《do-nothing》に簡約され、変更された環境が残ります。
# 私達はビッグステップ意味論の評価を、いつでも文と初期環境を
# 最終的な環境に変えるプロセスとして考えることができます。
# それはreduceメソッドで作られた中間状態を扱う必要があります
# 例えば、代入文のビッグステップ評価は式を完全に評価して
# 結果の値を含む更新された環境を返すべきです

class Assign
  def evaluate(environment)
    environment.merge({ name => expression.evaluate(environment) })
  end
end

# 同じようにDoNothingのevaluateメソッドは明らかに変更されてない環境を返し、
# Ifのevaluateメソッドは状態を評価し、帰結か代替のどちらかの評価結果を結果とする
# 環境を返す、というとても簡単な仕事です

class DoNothing
  def evaluate(environment)
    environment
  end
end

class If
  def evaluate(environment)
    case condition.evaluate(environment)
      when Boolean.new(true)
        consequence.evaluate(environment)
      when Boolean.new(false)
        alternative.evaluate(environment)
    end
  end
end

# 二つの興味深いケースはシーケンス文と《while》ループです。
# シーケンス文では私達はただ両方の文を評価する必要があるだけですが、
# 初期状態の環境は「一連の繋がった」二つの評価を必要とします
# なので、一つ目の文の評価結果は二つ目の文が評価される環境となります。
# これはRubyでは最初の評価結果を二つ目の引数に使うことで書けます。
class Sequence
  def evaluate(environment)
    second.evaluate(first.evaluate(environment))
  end
end

# 環境をスレッド化することは変数を準備するための文をより簡単にさせる核心です。

statement =
Sequence.new(
 Assign.new(:x, Add.new(Number.new(1), Number.new(1))),
 Assign.new(:y, Add.new(Variable.new(:x), Number.new(3)))
)

statement.evaluate({})

# 《while》文のために私達はループの完璧な評価段階を考える必要があります
# ・状態を真か偽のどちらかを得るように評価する
# ・もし状態が真に評価されたら、新しい環境を得るために中身を評価し、
# 　それからその新しい環境でループを繰り返す（while文全体を再び評価する）
# ・もし状態が偽に評価されたら、変更されてない環境を返す
#
# これはwhile文がどのように振る舞うべきかの再帰的な説明です。
# シーケンス文では、ループの中身によって作られる更新された環境が次の
# 繰り返しのために使われることが重要です。
# さもなければ状態は真であり続けることを決してやめず、
# ループが終わる機会が決してなくなるでしょう
# 私達はどのようににビッグステップのwhile文は振る舞うべきか知ったので
# whileクラスにevaluateメソッドを与えられます

class While
  def evaluate(environment)
    case condition.evaluate(environment)
      when Boolean.new(true)
        evaluate(body.evaluate(environment))
      when Boolean.new(false)
        environment
    end
  end
end

# これはどこでループが起きているか、つまりbody.evaluate(environment)が
# 新しい環境を得るためにループのbodyを評価し、それから私達は次の繰り返しを
# 始めるために環境を現在のメソッドに戻します、これは私達は次のwhileクラスの
# evaluateメソッドの実施の入れ子(ネスト)を状態が偽になって最終的な環境が
# 返されるまでたくさんスタックするかもしれないということを意味してます。
#
# この働きが正しいことを確かめるため、私達はスモールステップ意味論を
# チェックするために使ったのと同じwhile文を評価してみましょう

statement =
While.new(
 LessThan.new(Variable.new(:x), Number.new(5)),
 Assign.new(:x, Multiply.new(Variable.new(:x), Number.new(3)))
)

statement.evaluate({ x: Number.new(1) })

# これはスモールステップ意味論が与えた結果と同じです。なのでwhileクラスの
# evaluateメソッドは正しいことをするようです。
